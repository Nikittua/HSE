#  Лабораторная работа №6 «Обмен информацией через разделяемую память между асинхронными процессами»

Вариант №21

**Сервер**. Создать разделяемую область памяти (РОП) и набор семафоров (НС). При 
поступлении клиентского сообщения, определить время создания этих файлов, а также 
идентификатор процесса который последним отсоединялся от РОП. Удалить РОП и НС.

**Клиент**. Записать в РОП, созданную сервером сообщение, содержащее список всех 
файлов текущего каталога, представленных на машинном языке.

# Как выполнять

```
git clone https://github.com/Nikittua/HSE.git

cd /home/user/HSE/OSI/Laba6

g++ -o client client_prod.cpp
g++ -o server server_prod.cpp

Терминал 1:
./server

Терминал 2:
./client



```



# Файлы


## shared.h

В этом файле хранятся основные функции, а именно:

 - __createSemaphore()__ - Функция для создания и инициализации семафора: используется semget, который создает массив семафоров с одним семафором в нем и режимом создания массива IPC_CREAT | 0666

 - __manipulateSemaphore__ - Функция для увеличения значения семафора: Она использует функцию semop с параметрами, которые ожидают увеличения значения семафора на 1. В данном контексте, она служит для разблокировки сервера
----------------------------------------------------------------------


## server_prod.cpp


Инифиализируются нужные поля для создания семафора и РОП, создются сами семафор(функция __createSemaphore()__) и РОП с permission 666 `rw-rw-rw-`. 

Подключаемся к РОП и заполняем ее нулями(осищаем на случай наличия там мусора)

Вызывается функция __manipulateSemaphore()__ для ожидания клиента

Создаем объект структуры shmid_ds: */, shm_lpid  /* идентификатор процесса который последним отсоединялся от РОП */

Далее идет обработка имен файлов и вывод времени их создания используящая функцию getFileCreationTime, которая создает объект структуры stat и возвращает st_ctime и strtok, которая выполняет поиск лексем в строке 

Отсоединяемся от разделяемой памяти и удаляем РОП и семафор. Для этого использем shmctl и semctl с флагом IPC_RMID

### Выполнение
```bash
# Server
g++ -o server server_prod.cpp
.server
-------------------------

Output:

Ожидание клиента...
Содержимое разделяемой области памяти (РОП):
client
server

Имя файла: client, Время создания: Wed Oct 18 00:52:42 2023
Имя файла: server, Время создания: Wed Oct 18 00:52:42 2023

```
----------------------------------------------------------------------


## client_prod.cpp


Инициализируются нужные поля для получения доступа к массиву семафоров и РОП

Получаем доступ к существующим РОП и семафору

Подключаемся к уже очищенной РОП и записываем туда список исполняемых файлов с помощью функции __listELFExecutables()__

### Выполнение
```bash
# Client
g++ -o client client_prod.cpp
./client
-------------------------

Output:

ELF Executables:
client
server

```
----------------------------------------------------------------------

# TODO
~~Установить начальное значение семафора~~
~~сделать свой union~~

~~Инифиализируются нужные поля для получения доступа к массиву семафоров и РОП~~
~~Очищать память после присоединения к РОП~~

~~Получаем доступ к существующим РОП и семафору~~
~~Синхронизация процессов, а не "пауза"~~
~~Один процесс получил ресурс все другие заблокированны~~
~~Процесс поработал и что то сделал, он разблокирует какой то других, а сам себя блокирует~~

## Ресурсы:
https://www.opennet.ru/docs/RUS/xtoolkit/x-1.html#x-1-7-3-3
https://www.opennet.ru/man.shtml?topic=shmget&category=2&russian=0
https://www.opennet.ru/man.shtml?topic=shmctl&category=2&russian=0
https://www.opennet.ru/docs/RUS/ipcbook/node34.html
https://www.ibm.com/docs/ru/aix/7.2?topic=memory-creating-shared-segment-shmat-subroutine






