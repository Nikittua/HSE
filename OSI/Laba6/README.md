#  Лабораторная работа №6 «Обмен информацией через разделяемую память между асинхронными процессами»

Вариант №21

**Сервер**. Создать разделяемую область памяти (РОП) и набор семафоров (НС). При 
поступлении клиентского сообщения, определить время создания этих файлов, а также 
идентификатор процесса который последним отсоединялся от РОП. Удалить РОП и НС.

**Клиент**. Записать в РОП, созданную сервером сообщение, содержащее список всех 
файлов текущего каталога, представленных на машинном языке.

# Как выполнять

```
git clone https://github.com/Nikittua/HSE.git

cd /home/user/HSE/OSI/Laba6

g++ -o client client_prod.cpp
g++ -o server server_prod.cpp

Терминал 1:
./server

Терминал 2:
./client



```



# Файлы


## shared.h

В этом файле хранятся основные функции, а именно:

 - __createSemaphore()__ - Функция для создания и инициализации семафора: используется semget, который создает массив семафоров с одним семафором в нем и режимом создания массива IPC_CREAT | 0666

 - __waitForClient()__ - Функция для ожидания клиента: Она использует функцию semop с параметрами, которые ожидают уменьшения значения семафора на 1. Когда клиент будет готов, он вызовет signalServer()

 - __signalServer()__ - Функция для увеличения значения семафора: Она использует функцию semop с параметрами, которые ожидают увеличения значения семафора на 1. В данном контексте, она служит для отправки сигнала серверу о том, что клиент выполнил необходимые действия и готов передать данные или завершить работу
----------------------------------------------------------------------


## server_prod.cpp


Далее инифиализируются нужные поля для создания семафора и РОП, создются сами семафор(функция __createSemaphore()__) и РОП с permission 666 `rw-rw-rw-`. 

Вызывается функция __waitForClient()__ для ождиания клиента

После того как клиент уменьшил значение семафора, ожидание прекращается и идет присоединение к очереди.

Создается структура struct stat, которая будет использоваться для хранения информации о файле или директории. В нашем случае это текущая директория (".")

Далее с помощью функций получаем необходимую нам информацию из структур, определенных выше: st_ctime /* время последнего изменения */, shm_lpid  /* идентификатор последнего пользователя */

Отсоединяемся от разделяемой памяти и удаляем РОП и семафор. Для этого использем shmctl и semctl с флагом IPC_RMID

### Выполнение
```bash
# Server
g++ -o server server_prod.cpp
.server
-------------------------

Output:

Ожидание клиента...
Время создания файлов: Sat Sep  9 15:25:47 2023
Идентификатор процесса, последний отсоединившийся от РОП: 2377

```
----------------------------------------------------------------------


## client_prod.cpp
Инифиализируются нужные поля для получения доступа к массиву семафоров и РОП

Получаем доступ к существующим РОП и семафору

### Выполнение
```bash
# Client
g++ -o client client_prod.cpp
./client
-------------------------

Output:
client_prod.cpp
shared.h
..
README.md
server
.
client
server_prod.cpp


```
----------------------------------------------------------------------

# TODO
Установить начальное значение семафора
сделать свой union

Инифиализируются нужные поля для получения доступа к массиву семафоров и РОП
Очищать память после присоединения к РОП

Получаем доступ к существующим РОП и семафору
Синхронизация процессов, а не "пауза"
Один процесс получил ресурс все другие заблокированны
Процесс поработал и что то сделал, он разблокирует какой то других, а сам себя блокирует

## Ресурсы:
https://www.opennet.ru/docs/RUS/xtoolkit/x-1.html#x-1-7-3-3
https://www.opennet.ru/man.shtml?topic=shmget&category=2&russian=0
https://www.opennet.ru/man.shtml?topic=shmctl&category=2&russian=0
https://www.opennet.ru/docs/RUS/ipcbook/node34.html
https://www.ibm.com/docs/ru/aix/7.2?topic=memory-creating-shared-segment-shmat-subroutine






