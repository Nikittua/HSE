#  Лабораторная работа №6 «Обмен информацией через разделяемую память между асинхронными процессами»

Вариант №21

**Сервер**. Создать разделяемую область памяти (РОП) и набор семафоров (НС). При 
поступлении клиентского сообщения, определить время создания этих файлов, а также 
идентификатор процесса который последним отсоединялся от РОП. Удалить РОП и НС.

**Клиент**. Записать в РОП, созданную сервером сообщение, содержащее список всех 
файлов текущего каталога, представленных на машинном языке.

# Как выполнять





# Файлы


## shared.h

В этом файле хранятся основные функции, а именно:

 - __createSemaphore()__ - Функция для создания и инициализации семафора: используется semget, который создает массив семафоров с одним семафором в нем и режимом создания массива IPC_CREAT | 0666

 - __waitForClient()__ - Функция для ожидания клиента: Она использует функцию semop с параметрами, которые ожидают уменьшения значения семафора на 1. Когда клиент будет готов, он вызовет signalServer()

 - __signalServer()__ - Функция для увеличения значения семафора: Она использует функцию semop с параметрами, которые ожидают увеличения значения семафора на 1. В данном контексте, она служит для отправки сигнала серверу о том, что клиент выполнил необходимые действия и готов передать данные или завершить работу
----------------------------------------------------------------------


## server_prod.cpp


Далее инифиализируются нужные поля для создания семафора и РОП, создются сами семафор(функция __createSemaphore()__) и РОП с permission 666 `rw-rw-rw-`. 

Вызывается функция __waitForClient()__ для ождиания клиента

После того как клиент уменьшил значение семафора, ожидание прекращается и идет присоединение к очереди.

Создается структура struct stat, которая будет использоваться для хранения информации о файле или директории. В нашем случае это текущая директория (".")

Далее с помощью функций получаем необходимую нам информацию из структур, определенных выше: st_ctime /* время последнего изменения */, shm_lpid  /* идентификатор последнего пользователя */

Отсоединяемся от разделяемой памяти и удаляем РОП и семафор. Для этого использем shmctl и semctl с флагом IPC_RMID

### Выполнение
```bash
# Server
g++ -o server_prod server_prod.cpp
.server_prod
-------------------------

Output:

Ожидание клиента...
Время создания файлов: Sat Sep  9 15:25:47 2023
Идентификатор процесса, последний отсоединившийся от РОП: 2377

```
----------------------------------------------------------------------


## client_prod.cpp
Инифиализируются нужные поля для получения доступа к массиву семафоров и РОП

Получаем доступ к существующим РОП и семафору

### Выполнение
```bash
# Client
g++ -o get_pid get_pid.cpp
./get_pid
-------------------------

Output:
Время последнего чтения из очереди: Sat Sep  2 14:21:58 2023
Число сообщений в очереди: 1

```
----------------------------------------------------------------------

## read_msg.cpp

Аналогично с client_prod.cpp, но выполняется лишь функция __receiveMessage()__ для чтения сообщения и дальнейший его вывод.

Будет использоваться при желании для демонстрации того, что функция __getLastReadTime()__ работает корреткно 

### Выполнение
```bash
g++ -o read_msg read_msg.cpp
./read_msg.cpp
-------------------------

Ожидаемый вывод:
Полученное сообщение: Time:36-23:24:49
```



# TODO

~~Понять как получить идентификатор самого «старого» работающего 
процесса из информации об очереди: вроде как делается с помощью __msg_lrpid__, но везде написано что __msg_lrpid__ - pid последнего процесса вызвавшего __msgrcv()__. Но считается ли он самым «старым» работающим
процессом~~ 

~~Удалить очередь сообщений: должно делаться с помощью __IPC_RMID__~~

## Ресурсы:
https://www.ibm.com/docs/en/aix/7.2?topic=i-ipcs-command
https://www.opennet.ru/base/dev/ipc_msg.txt.html
https://www.opennet.ru/docs/RUS/linux_base/node212.html
https://it.wikireading.ru/14109






